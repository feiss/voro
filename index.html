<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>A-Frame T-Shirt designer</title>
  <script src="rhill-voronoi-core.min.js"></script>
  <style>
    body {
      background: #ccc;
      margin: 0;
    }
    svg {
      background: #fff;
      width: 500px;
      height: 500px;
      margin: 0px;
    }
    #log {
      font: 12px monospace;
    }
  </style>
</head>
<body>
<svg id="svg">
  <g id="logo"></g>
</svg>
<div id="log"></div>
<script>
var shapes_raw = [
  [0,0, 63.503,121.029, 653.545,121.029, 716.673, 0],
  [93.979,179.112, 359.403,684.965, 623.250,179.112],
  [389.869,742.947, 499.837,952.616, 1000,0, 777.789,0]
];
//make point objects and flip y
var shapes = [];
for (var i = 0; i < shapes_raw.length; i++) {
  var shape = [];
  for (var j = 0; j < shapes_raw[i].length; j += 2) {
    shape.push({ x: shapes_raw[i][j], y: 1000.0 - shapes_raw[i][j + 1]});
  }
  shapes.push(shape);
}

var cells;

function calcVoronoi(num) {
  var voronoi = new Voronoi();
  var bbox = {xl: 0, xr: 1000, yt: 0, yb: 1000}; 
  var sites = [];
  for (var i = 0; i < num; i++) {
    sites.push({x: Math.random() * 1000, y: Math.random() * 1000});
  }
  var diagram = voronoi.compute(sites, bbox);
  cells = [];
  for (var i = 0; i < diagram.cells.length; i++) {
    cells.push(getCell(diagram.cells[i]));
  }
}

function getCell (site) {
  var verts = [];
  if (site.halfedges.length == 0) return;
  var s = {x: site.site.x, y: site.site.y};
  for (var i = 0; i < site.halfedges.length; i++) {
    var va = site.halfedges[i].edge.va, vb =  site.halfedges[i].edge.vb;
    verts.push({x: va.x, y: va.y, a: Math.atan2(va.y - s.y, va.x - s.x)});
    verts.push({x: vb.x, y: vb.y, a: Math.atan2(vb.y - s.y, vb.x - s.x)});
  }
  verts.sort(function (a, b) { return a.a < b.a ? 1 : (a.a > b.a ? -1 : 0) });
  return {center: s, vertices: verts};
}

function inside(point, vs) {
    // https://stackoverflow.com/questions/22521982/js-check-if-point-inside-a-polygon
    // ray-casting algorithm based on
    // http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
    var x = point.x, y = point.y;

    var inside = false;
    for (var i = 0, j = vs.length - 1; i < vs.length; j = i++) {
        var xi = vs[i].x, yi = vs[i].y;
        var xj = vs[j].x, yj = vs[j].y;

        var intersect = ((yi > y) != (yj > y))
            && (x < (xj - xi) * (y - yi) / (yj - yi) + xi);
        if (intersect) inside = !inside;
    }
    return inside;
}

function trimCells() {
  for (var i = 0; i < cells.length; i++) {
    var cp = cells[i].center;
    if (!inside(cp, shapes[0]) && !inside(cp, shapes[1]) && !inside(cp, shapes[2])) {
      cells.splice(i, 1);
      i--;
    }
  }
}


function randomColor() {
  var hex = '0123456789ABCDEF';
  var h = hex[Math.floor(Math.random() * 4)];
  return '#' + h + h + h;
}

var svg = document.getElementById('svg');
var logo = document.getElementById('logo');
var data;
var zoom = 1;


function getCellsSVG(cells) {
  var data = '';
  for (var c = 0; c < cells.length; c++) {
    var cell = cells[c];
    data += '<path style="stroke:#fff;fill:' + randomColor() + '" d="';
    data += 'M' + cell.vertices[0].x + ' ' + cell.vertices[0].y;
    for (var i = 1; i < cell.vertices.length; i ++) {
      data += ' ' + cell.vertices[i].x + ' ' + cell.vertices[i].y;
    }
    data += 'z"/>\n';
    //data += '<circle cx="' + cell.center.x + '" cy="' + cell.center.y + '" r="3"/>';
  }
  return data;
}

function refreshView() {
  var viewBox = zoom * 1000.0;
  var pan =  (viewBox - 1000) / 2;
  svg.setAttribute('viewBox', '0 0 ' + viewBox + ' ' + viewBox);
  logo.setAttribute('transform', 'translate(' + pan + ' ' + pan + ')')
}

svg.addEventListener('wheel', function (evt) {
  zoom += evt.deltaY / 20;
  refreshView();
});
svg.addEventListener('mousemove', function (evt) {
  document.getElementById('log').innerHTML = (evt.clientX*2 |0) + ', ' + (evt.clientY*2|0);
});

refreshView();

calcVoronoi(600);
trimCells();
logo.innerHTML = getCellsSVG(cells);

</script>      
</body>
</html>

